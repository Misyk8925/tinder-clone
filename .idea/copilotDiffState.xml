<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/services/deck/src/main/java/com/tinder/deck/auth/KeycloakTokenClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/deck/src/main/java/com/tinder/deck/auth/KeycloakTokenClient.java" />
              <option name="updatedContent" value="package com.tinder.deck.auth;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;import lombok.NoArgsConstructor;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.stereotype.Component;&#10;import org.springframework.util.LinkedMultiValueMap;&#10;import org.springframework.util.MultiValueMap;&#10;import org.springframework.web.reactive.function.BodyInserters;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;import reactor.core.publisher.Mono;&#10;&#10;import java.time.Duration;&#10;import java.time.Instant;&#10;import java.util.concurrent.atomic.AtomicReference;&#10;&#10;/**&#10; * Reactive Keycloak token client using client_credentials grant&#10; * Caches token in-memory until near expiry and refreshes on demand&#10; */&#10;@Component&#10;public class KeycloakTokenClient {&#10;    private static final Logger log = LoggerFactory.getLogger(KeycloakTokenClient.class);&#10;&#10;    private final WebClient http;&#10;    private final String tokenUri;&#10;    private final String clientId;&#10;    private final String clientSecret;&#10;    private final String scope;&#10;    private final long skewSeconds;&#10;&#10;    private final AtomicReference&lt;CachedToken&gt; cache = new AtomicReference&lt;&gt;();&#10;&#10;    public KeycloakTokenClient(&#10;            @Value(&quot;${keycloak.token-uri:}&quot;) String tokenUri,&#10;            @Value(&quot;${keycloak.client-id:}&quot;) String clientId,&#10;            @Value(&quot;${keycloak.client-secret:}&quot;) String clientSecret,&#10;            @Value(&quot;${keycloak.scope:}&quot;) String scope,&#10;            @Value(&quot;${keycloak.clock-skew-seconds:30}&quot;) long skewSeconds&#10;    ) {&#10;        this.http = WebClient.builder()&#10;                .codecs(c -&gt; c.defaultCodecs().maxInMemorySize(256 * 1024))&#10;                .build();&#10;        this.tokenUri = tokenUri;&#10;        this.clientId = clientId;&#10;        this.clientSecret = clientSecret;&#10;        this.scope = scope;&#10;        this.skewSeconds = skewSeconds;&#10;    }&#10;&#10;    public boolean isConfigured() {&#10;        return tokenUri != null &amp;&amp; !tokenUri.isBlank()&#10;                &amp;&amp; clientId != null &amp;&amp; !clientId.isBlank()&#10;                &amp;&amp; clientSecret != null &amp;&amp; !clientSecret.isBlank();&#10;    }&#10;&#10;    // Get current valid access token (reactive, non-blocking)&#10;    public Mono&lt;String&gt; getAccessToken() {&#10;        if (!isConfigured()) {&#10;            return Mono.empty();&#10;        }&#10;        CachedToken ct = cache.get();&#10;        if (ct != null &amp;&amp; !ct.isExpired(skewSeconds)) {&#10;            return Mono.just(ct.accessToken);&#10;        }&#10;        return requestNewToken()&#10;                .doOnNext(token -&gt; cache.set(new CachedToken(token.value, token.expiresAt)))&#10;                .map(Token::value);&#10;    }&#10;&#10;    private Mono&lt;Token&gt; requestNewToken() {&#10;        MultiValueMap&lt;String, String&gt; form = new LinkedMultiValueMap&lt;&gt;();&#10;        form.add(&quot;grant_type&quot;, &quot;client_credentials&quot;);&#10;        form.add(&quot;client_id&quot;, clientId);&#10;        form.add(&quot;client_secret&quot;, clientSecret);&#10;        if (scope != null &amp;&amp; !scope.isBlank()) {&#10;            form.add(&quot;scope&quot;, scope);&#10;        }&#10;&#10;        return http.post()&#10;                .uri(tokenUri)&#10;                .contentType(MediaType.APPLICATION_FORM_URLENCODED)&#10;                .body(BodyInserters.fromFormData(form))&#10;                .retrieve()&#10;                .bodyToMono(TokenResponse.class)&#10;                .timeout(Duration.ofSeconds(10))&#10;                .map(tr -&gt; {&#10;                    long expiresIn = tr.getExpires_in() != null ? tr.getExpires_in() : 300L;&#10;                    Instant expiresAt = Instant.now().plusSeconds(expiresIn);&#10;                    log.debug(&quot;Obtained Keycloak access token, expires in {}s&quot;, expiresIn);&#10;                    return new Token(tr.getAccess_token(), expiresAt);&#10;                })&#10;                .doOnError(e -&gt; log.warn(&quot;Failed to obtain Keycloak token: {}&quot;, e.toString()));&#10;    }&#10;&#10;    private record Token(String value, Instant expiresAt) {}&#10;&#10;    @Data&#10;    @NoArgsConstructor&#10;    @AllArgsConstructor&#10;    static class TokenResponse {&#10;        private String access_token;&#10;        private String token_type;&#10;        private Long expires_in;&#10;        private Long refresh_expires_in;&#10;        private String scope;&#10;        private String session_state;&#10;    }&#10;&#10;    private record CachedToken(String accessToken, Instant expiresAt) {&#10;        boolean isExpired(long skewSec) {&#10;            return Instant.now().isAfter(expiresAt.minusSeconds(skewSec));&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/deck/src/main/java/com/tinder/deck/service/DeckService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/deck/src/main/java/com/tinder/deck/service/DeckService.java" />
              <option name="originalContent" value="package com.tinder.deck.service;&#10;&#10;import com.tinder.deck.adapters.ProfilesHttp;&#10;import com.tinder.deck.adapters.SwipesHttp;&#10;import com.tinder.deck.dto.SharedPreferencesDto;&#10;import com.tinder.deck.dto.SharedProfileDto;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;import reactor.core.publisher.Flux;&#10;import reactor.core.publisher.Mono;&#10;import reactor.core.scheduler.Schedulers;&#10;&#10;import java.time.Duration;&#10;import java.util.*;&#10; import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;public class DeckService {&#10;&#10;    private final ProfilesHttp profilesHttp;&#10;    private final SwipesHttp swipesHttp;&#10;    private final DeckCache cache;&#10;    private final ScoringService scoring;&#10;&#10;    @Value(&quot;${deck.parallelism:32}&quot;)     private int parallelism;&#10;    @Value(&quot;${deck.request-timeout-ms}&quot;) private long timeoutMs;&#10;    @Value(&quot;${deck.retries:1}&quot;)          private long retries;&#10;    @Value(&quot;${deck.ttl-minutes:60}&quot;)     private long ttlMin;&#10;    @Value(&quot;${deck.per-user-limit:500}&quot;) private int perUserLimit;&#10;    @Value(&quot;${deck.search-limit:2000}&quot;)  private int searchLimit;&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(DeckService.class);&#10;&#10;    public Mono&lt;Void&gt; rebuildOneDeck(SharedProfileDto viewer) {&#10;        SharedPreferencesDto prefs = viewer.preferences();&#10;        final long start = System.currentTimeMillis();&#10;        log.info(&quot;Rebuild deck started for viewer {}&quot;, viewer.id());&#10;&#10;        // 1) Candidates from Profiles by filters&#10;        Flux&lt;SharedProfileDto&gt; candidates = profilesHttp&#10;                .searchProfiles(&#10;                        viewer.id(),&#10;                        prefs, searchLimit&#10;                )&#10;                .doOnSubscribe(s -&gt; log.debug(&quot;Search profiles subscribed for viewer {}&quot;, viewer.id()))&#10;                .doOnError(e -&gt; log.warn(&quot;Profiles search failed for viewer {}: {}&quot;, viewer.id(), e.toString()))&#10;                .retry(retries)&#10;                .onErrorResume(e -&gt; Flux.empty());&#10;&#10;        // 2) Batch check of swipes (glue into batches of 200, for example)&#10;        Flux&lt;SharedProfileDto&gt; filtered = candidates&#10;                .buffer(200)&#10;                .concatMap(batch -&gt; {&#10;                    List&lt;UUID&gt; ids = batch.stream().map(SharedProfileDto::id).toList();&#10;                    log.debug(&quot;Processing swipe batch of size {} for viewer {}&quot;, ids.size(), viewer.id());&#10;                    return swipesHttp.betweenBatch(viewer.id(), ids)&#10;                            .timeout(Duration.ofMillis(timeoutMs))&#10;                            .retry(retries)&#10;                            .doOnError(e -&gt; log.warn(&quot;Swipes batch failed for viewer {} batchSize {}: {}&quot;, viewer.id(), ids.size(), e.toString()))&#10;                            .onErrorReturn(Collections.emptyMap())&#10;                            .flatMapMany(map -&gt; Flux.fromIterable(batch)&#10;                            .flatMapMany(map -&gt; Flux.fromIterable(batch)&#10;                                    .filter(c -&gt; !map.getOrDefault(c.id(), false))); // false =&gt; no record — candidate is good&#10;                .parallel(parallelism).runOn(Schedulers.parallel())&#10;                .map(c -&gt; Map.entry(c.id(), scoring.score(viewer, c)))&#10;                .sequential()&#10;                .sort(Comparator.comparingDouble(Map.Entry&lt;UUID, Double&gt;::getValue).reversed())&#10;                .collectList()&#10;                // 4) Write to Redis ZSET&#10;                .flatMap(deck -&gt; {&#10;                    log.info(&quot;Deck prepared for viewer {} with size {}. Writing to cache...&quot;, viewer.id(), deck.size());&#10;                    return cache.writeDeck(viewer.id(), deck, Duration.ofMinutes(ttlMin))&#10;                            .doOnSuccess(v -&gt; log.info(&quot;Deck written for viewer {} in {} ms&quot;, viewer.id(), System.currentTimeMillis() - start));&#10;                })&#10;                .doOnError(e -&gt; log.error(&quot;Failed to rebuild deck for viewer {}: {}&quot;, viewer.id(), e.toString()));&#10;    }&#10;" />
              <option name="updatedContent" value="package com.tinder.deck.service;&#10;&#10;import com.tinder.deck.adapters.ProfilesHttp;&#10;import com.tinder.deck.adapters.SwipesHttp;&#10;import com.tinder.deck.dto.SharedPreferencesDto;&#10;import com.tinder.deck.dto.SharedProfileDto;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;import reactor.core.publisher.Flux;&#10;import reactor.core.publisher.Mono;&#10;import reactor.core.scheduler.Schedulers;&#10;&#10;import java.time.Duration;&#10;import java.util.*;&#10; import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;public class DeckService {&#10;&#10;    private final ProfilesHttp profilesHttp;&#10;    private final SwipesHttp swipesHttp;&#10;    private final DeckCache cache;&#10;    private final ScoringService scoring;&#10;&#10;    @Value(&quot;${deck.parallelism:32}&quot;)     private int parallelism;&#10;    @Value(&quot;${deck.request-timeout-ms}&quot;) private long timeoutMs;&#10;    @Value(&quot;${deck.retries:1}&quot;)          private long retries;&#10;    @Value(&quot;${deck.ttl-minutes:60}&quot;)     private long ttlMin;&#10;    @Value(&quot;${deck.per-user-limit:500}&quot;) private int perUserLimit;&#10;    @Value(&quot;${deck.search-limit:2000}&quot;)  private int searchLimit;&#10;&#10;    private static final Logger log = LoggerFactory.getLogger(DeckService.class);&#10;&#10;    public Mono&lt;Void&gt; rebuildOneDeck(SharedProfileDto viewer) {&#10;        SharedPreferencesDto prefs = viewer.preferences();&#10;        &#10;        // Use default preferences if null&#10;        if (prefs == null) {&#10;            log.warn(&quot;Viewer {} has null preferences, using defaults&quot;, viewer.id());&#10;            prefs = new SharedPreferencesDto(18, 50, &quot;ANY&quot;, 100);&#10;        }&#10;        &#10;        final SharedPreferencesDto finalPrefs = prefs;&#10;        final long start = System.currentTimeMillis();&#10;        log.info(&quot;Rebuild deck started for viewer {} with preferences: gender={}, age={}-{}&quot;, &#10;                viewer.id(), finalPrefs.gender(), finalPrefs.minAge(), finalPrefs.maxAge());&#10;&#10;        // 1) Candidates from Profiles by filters&#10;        Flux&lt;SharedProfileDto&gt; candidates = profilesHttp&#10;                .searchProfiles(&#10;                        viewer.id(),&#10;                        finalPrefs, searchLimit&#10;                )&#10;                .doOnSubscribe(s -&gt; log.debug(&quot;Search profiles subscribed for viewer {}&quot;, viewer.id()))&#10;                .doOnNext(c -&gt; log.debug(&quot;Received candidate {} for viewer {}&quot;, c.id(), viewer.id()))&#10;                .timeout(Duration.ofMillis(timeoutMs))&#10;                .doOnError(e -&gt; log.warn(&quot;Profiles search failed for viewer {}: {}&quot;, viewer.id(), e.toString()))&#10;                .retry(retries)&#10;                .onErrorResume(e -&gt; Flux.empty());&#10;&#10;        // 2) Batch check of swipes (glue into batches of 200, for example)&#10;        Flux&lt;SharedProfileDto&gt; filtered = candidates&#10;                .buffer(200)&#10;                .concatMap(batch -&gt; {&#10;                    List&lt;UUID&gt; ids = batch.stream().map(SharedProfileDto::id).toList();&#10;                    log.debug(&quot;Processing swipe batch of size {} for viewer {}&quot;, ids.size(), viewer.id());&#10;                    return swipesHttp.betweenBatch(viewer.id(), ids)&#10;                            .timeout(Duration.ofMillis(timeoutMs))&#10;                            .retry(retries)&#10;                            .doOnError(e -&gt; log.warn(&quot;Swipes batch failed for viewer {} batchSize {}: {}&quot;, viewer.id(), ids.size(), e.toString()))&#10;                            .onErrorReturn(Collections.emptyMap())&#10;                            .flatMapMany(map -&gt; {&#10;                                log.debug(&quot;Swipe map returned {} entries for viewer {}&quot;, map.size(), viewer.id());&#10;                                return Flux.fromIterable(batch)&#10;                                        .filter(c -&gt; !map.getOrDefault(c.id(), false));&#10;                            }); // false =&gt; no record — candidate is good&#10;                }, 1); // sequential processing of batches (so as not to blow up Swipes)&#10;&#10;        // 3) Scoring + sorting + limiting&#10;        return filtered&#10;                .doOnNext(c -&gt; log.debug(&quot;Filtered candidate {} for viewer {}&quot;, c.id(), viewer.id()))&#10;                .parallel(parallelism).runOn(Schedulers.parallel())&#10;                .map(c -&gt; Map.entry(c.id(), scoring.score(viewer, c)))&#10;                .sequential()&#10;                .sort(Comparator.comparingDouble(Map.Entry&lt;UUID, Double&gt;::getValue).reversed())&#10;                .take(perUserLimit)&#10;                .collectList()&#10;                // 4) Write to Redis ZSET&#10;                .flatMap(deck -&gt; {&#10;                    log.info(&quot;Deck prepared for viewer {} with size {}. Writing to cache...&quot;, viewer.id(), deck.size());&#10;                    if (deck.isEmpty()) {&#10;                        log.warn(&quot;Empty deck for viewer {} - no candidates found after filtering&quot;, viewer.id());&#10;                    }&#10;                    return cache.writeDeck(viewer.id(), deck, Duration.ofMinutes(ttlMin))&#10;                            .doOnSuccess(v -&gt; log.info(&quot;Deck written for viewer {} in {} ms&quot;, viewer.id(), System.currentTimeMillis() - start));&#10;                })&#10;                .doOnError(e -&gt; log.error(&quot;Failed to rebuild deck for viewer {}: {}&quot;, viewer.id(), e.toString()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/profiles/src/main/java/com/tinder/profiles/user/KeycloakWebClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/profiles/src/main/java/com/tinder/profiles/user/KeycloakWebClient.java" />
              <option name="originalContent" value="package com.tinder.profiles.user;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;&#10;@Configuration&#10;public class KeycloakWebClient {&#10;    @Bean(&quot;keycloakWebClient&quot;)&#10;    WebClient keycloakWebClient(&#10;            @Value(&quot;${keycloak.auth-server-url}&quot;) String keycloakUrl&#10;    ) {&#10;        return WebClient.builder()&#10;                .baseUrl(keycloakUrl)&#10;                .build();&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.tinder.profiles.user;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;&#10;@Configuration&#10;public class KeycloakConfig {&#10;    @Bean(&quot;keycloakWebClient&quot;)&#10;    public WebClient keycloakWebClient(&#10;            @Value(&quot;${keycloak.auth-server-url}&quot;) String keycloakUrl&#10;    ) {&#10;        return WebClient.builder()&#10;                .baseUrl(keycloakUrl)&#10;                .build();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>